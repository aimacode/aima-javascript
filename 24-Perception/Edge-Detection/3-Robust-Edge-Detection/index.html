<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
	<title>24 Perception - Detecting Gradients</title>
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">
	<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
	<link rel="stylesheet" href="/styles.css">
	<link rel="stylesheet" href="../css/style.css">
	<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
	<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

	<script type="text/javascript" src="/main.js"></script>
</head>

<body>
	<div class="container-fluid">
		<div class="row">
			<div class="col-sm-6 col-md-offset-3" id="content">

				<h1>Robust Edge Detection</h1>
				<br>

				<h2>Gaussian Smoothing</h2>
				<p>
					The Sobel operator is a good start at edge detection, but it comes with its own share of faults.
					One problem with solely using Sobel is that it is very susceptible to <strong>noise</strong>. Our
					current approach
					would count a single bright pixel in a sea of dark pixels as an edge which is undesirable.
				</p>

				<br>
				<img src="/third-party/shannon-01.png" alt="Edge detection on noisy input" class="center display-image">
				<br><br>

				<p>
					To reduce noise in an image, we can choose to do <strong>Gaussian smoothing</strong> before
					attempting to apply
					the Sobel operator. How Gaussian smoothing is done is very similar to Sobel; using a filter and
					convolution to change the source image. The filter this time, however, is an approximation of the
					Gaussian function or normal distribution in 2D.
				</p>

				<br>
				<img src="/third-party/gaussian-2d.png" alt="2D gaussian function" class="center display-image">
				<br><br>

				<p>
					Applying this filter has the effect of smoothing out the intensities in an image which then
					allows an edge detector, like Sobel, to produce better results.
				</p>

				<br>
				<img src="/third-party/shannon-02.png" alt="Edge detection on noisy input after gaussian blur"
					class="center display-image">
				<br><br>

				<h2>Non-Maximum Suppression</h2>
				<p>
					While performing Gaussian smoothing before applying Sobel helps to reduce noise, the edge detection
					with
					Sobel at this stage is still unsatisfactory, usually leaving behind a number of thick and blurry
					edges. Ideally,
					we would want to thin these edges down. This is because producing thinner edges have many advantages
					when feeding
					an edge-detected image further down an image processing pipeline, such as being able to do more
					accurate
					object detection or perimeter calculation, for example.
				</p>

				<p>
					To thin down our edges, one approach is to try to get rid of, or <strong>suppress</strong>,
					the pixels with smaller gradient magnitudes within a blurry edge. This leaves behind only the
					pixels with the sharpest intensity changes, making this a form of <strong>non-maximum
						suppression</strong>. For every pixel, the
					gradient magnitudes of the two nearest pixels pointed at in both the positive and negative
					directions
					of the current pixel’s gradient are checked. If our current pixel has a greater magnitude than both
					of them, we keep its current value. Otherwise, we suppress it by setting its magnitude to 0.
				</p>

				<p>
					Below is a demonstration of non-maximum suppression on a single pixel. Paint the pixels around it
					and
					notice the relationship between the direction of the gradient and the pixels we are interested in
					checking.
					Remember that the vectors of greatest magnitude are red and that we are suppressing pixels on
					a basis of gradient magnitude and not intensity.
				</p>

				<br>
				<div id="suppression-root"></div>
				<br>

				<br>

				<h2>Double Threshold</h2>
				<p>
					While non-maximum suppression gets rid of most of the unwanted pixels along an edge, some get left
					behind.
					We can clean them up by performing a <strong>double threshold</strong> which defines an
					empirically-determined high and low threshold
					to classify and cull pixels. Pixels above the high threshold are marked as strong edges, pixels
					between
					the high and low thresholds are marked as weak edges, and pixels below the low threshold are
					suppressed.
				</p>

				<br>
				<div id="threshold-root"></div>
				<br>

				<h2>Edge Tracking by Hysteresis</h2>
				<p>
					At this stage, we are still left with several wrongly marked edges. While strong edges are most
					likely true edges,
					weak edges could be true edges or may simply be badly classified. How do we determine which weak
					edges to keep and
					which to throw away? Usually, the weak edges that we want are connected or adjacent to strong edges
					while the
					unwanted weak edges are isolated. Thus it is possible to do <strong>blob analysis</strong> where we
					search each weak
					edge’s
					8-pixel neighborhood for a strong edge. If a strong edge exists in the neighborhood, the weak edge
					is kept,
					otherwise it is thrown away.
				</p>

				<br>
				<img src="../images/blobAnalysis.png" alt="Example of keeping or suppressing weak edge using blob"
					class="center display-image">
				<br><br>

				<h2>Canny Edge Detection</h2>
				<p>
					We could keep processing our image and fine tuning our edge detection process, but usually images at
					this
					stage have their edges detected reasonably well. From a photograph, we have managed to apply a
					sequence of
					techniques that extracts edges to some degree of satisfaction. In fact, this pipeline as a whole is
					an
					algorithm known as <strong>Canny edge detection</strong>, created by John Canny in 1986. Despite its
					age
					and various improvements in the field of computer vision and computing power since it was first
					conceived,
					Canny edge detection still remains one of the most effective and widely-used edge detection
					algorithms today.
				</p>
				<p>
					In summary, edge detection provides a way for machines to decode visual information, something we
					humans take
					for granted, by simplifying a complex image into a simpler one which outlines the boundaries of the
					objects in
					a scene. Edge detection opens many doors within computer vision, serving as a foundational step for
					more
					complicated algorithms such as those for image segmentation and object detection.
				</p>
				<p>
					To do edge detection on a color image, we perform the following sequence of steps:
				</p>
				<ol>
					<li>Convert the image to grayscale intensities</li>
					<li>Blur the image to reduce noise</li>
					<li>Apply the Sobel operator to crudely find edges</li>
					<li>Perform non-maximum suppression, double thresholding, and edge tracking by hysteresis to thin
						and clean detected edges</li>
				</ol>
				<p>
					This sequence is famously known as Canny edge detection, an early edge detection algorithm that
					still remains popular in computing.
				</p>
				<br>
				<div id="sobel-image-root"></div>
				<br>
				<br>
				<br>

				<div class="row">
					<div class="col-sm-6 text-left">
						<a href="../2-Detecting-Gradients/"><<< Prev</a>
					</div>
					<div class="col-sm-6 text-right">
					</div>
				</div>
				<br>
			</div>
		</div>
	</div>


	<!-- Replace with third party -->
	<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
	<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/106/three.js"></script>
	<script src="/third-party/OrbitControls.js"></script>


	<script type="text/javascript" src="../js/setup.js"></script>
	<script type="text/javascript" src="../js/util.js"></script>
	<script type="text/javascript" src="../js/ui.js"></script>
	<script type="text/javascript" src="../js/imageProcessing.js"></script>

	<script type="text/javascript" src="./js/demoSuppression.js"></script>
	<script type="text/javascript" src="./js/demoThreshold.js"></script>
	<script type="text/javascript" src="./js/demoSobelImage.js"></script>

	<script type="text/javascript">
		// mobile setup
		document.ontouchmove = function (event) {
			event.preventDefault();
		}
	</script>

</body>

</html>