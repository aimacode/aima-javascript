<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
	<title>Edge Detection - Finding Edges</title>

	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">
	<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
	<link rel="stylesheet" href="/styles.css">
	<link rel="stylesheet" href="../css/style.css">
	<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
	<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

	<script type="text/javascript" src="/main.js"></script>
</head>

<body class="flex-content-container">
	<div class="flex-content">
		<div class="content-container" id="content">
			<div style="display: flex; flex-direction: column; row-gap: 1em;">

				<h1>Finding Edges</h1>

				<p>
					We have defined edges as locations where drastic changes in intensity occur. To find these
					locations, we need some way of quantifying how much the intensity changes as we move across the
					pixels in our image. To illustrate this problem, let us re-imagine our pixel array as a 3D
					topological map, correlating the intensity of each pixel with height on the map.
				</p>

				<div id="topology-root"></div>

				<p>
					Picking an arbitrary point on this map, we want to figure out the change in elevation around that
					point. Knowing the pointâ€™s height alone is relatively unhelpful since, although it may tell us how
					high up it is, we get no information about the changes around it. What if, in addition, we also
					considered the height of land a small distance away from our chosen point? Ah-hah! Now by comparing
					these nearby heights, we can get some idea of the local elevation changes around the point!
				</p>

				<img src="../images/elevation.png" alt="Elevation comparison example" class="center display-image">

				<p>
					This is the driving principle behind a well-known edge detector called the <strong>Sobel
						operator</strong>. The operator works by dragging two <strong>kernels</strong> or
					<strong>filters</strong> called Sobel X and Sobel Y across an image to calculate horizontal and
					vertical intensity changes respectively. For each target pixel in the image, the kernel covers and
					performs an operation on a neighborhood of surrounding pixels. We compare the intensity of these
					neighboring pixels with each other and use them to compute the change of intensity at the target
					pixel. To demonstrate this, below is an interactive example using the Sobel X filter. Use your mouse
					to drag the filter around and see how different areas reflect different intensity changes.
				</p>

				<div id="convolution-root"></div>

				<p>
					These filters are actually grids of numerical weights that are matched up to each neighborhood of
					pixels. The filter weights and the pixel intensities are used in a weighted sum to
					calculate a metric of change at each target pixel. In general, this concept of operating on a grid
					of values by dragging a smaller grid of values across it is a powerful mathematical idea that goes
					beyond edge detection known as <strong>convolution</strong>.
				</p>

				<img src="../images/filters.png" alt="Sobel X and Y filters" class="center display-image">

				<p>
					The end result of applying both the Sobel X and Sobel Y filters to our image is two grids containing
					values that represent horizontal and vertical changes respectively. These values can also be thought
					of as the X and Y components for a grid of 2D arrows or <strong>vectors</strong>. The vectors gotten
					using the Sobel operator are known as <strong>gradients</strong>. For a given pixel, the magnitude
					of the gradient tells us how much overall intensity change occurs at the pixel and the angle tells
					us the general direction of that change.
				</p>

				<p>
					Below is a demonstration that calculates image gradients. Draw edges or select one of the preset
					images and observe how the direction and magnitude of the gradient vectors change in response.
				</p>

				<div id="gradient-root"></div>

				<p>
					So far, our algorithm consists of taking a color image, converting it to grayscale intensities,
					and applying the Sobel operator to it to find the image's gradients. Observing the magnitudes
					of these gradients, we can already see edges begin to manifest as lit-up pixels where intensity
					change is strong.
				</p>

				<div id="pipeline2d-short-root"></div>

				<p>
					Plugging images through our current algorithm, you may have already noticed that Sobel by itself
					does not perform very well. Our edge detection is not very good at producing clean edges or dealing
					with grainy images. In the next section, we will address these problems by adding a variety of pre
					and post processing techniques into our working edge detection pipeline.
				</p>

				<img src="/third-party/shannon-01.png" alt="Edge detection on noisy input" class="center display-image">

			</div>

			<hr>
			<div class="row">
				<div class="col-sm-6 text-left">
					<a href="../1-Introduction/"><i class="fas fa-arrow-left"></i> Prev</a>
				</div>
				<div class="col-sm-6 text-right">
					<a href="../3-Robust-Edge-Detection/">Next <i class="fas fa-arrow-right"></i></a>
				</div>
			</div>
			<br>
		</div>
	</div>


	<!-- Replace with third party -->
	<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
	<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/106/three.js"></script>
	<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script src="/third-party/OrbitControls.js"></script>
	<script src="/third-party/vis.min.js"></script>

	<script type="text/javascript" src="../js/setup.js"></script>
	<script type="text/javascript" src="../js/util.js"></script>
	<script type="text/javascript" src="../js/ui.js"></script>
	<script type="text/javascript" src="../js/imageProcessing.js"></script>

	<script type="text/javascript" src="./js/demoConvolution.js"></script>
	<script type="text/javascript" src="./js/demoGradient.js"></script>
	<script type="text/javascript" src="./js/demoTopology.js"></script>
	<script type="text/javascript" src="../js/demoPipeline2D.js"></script>

	<script type="text/javascript">
		// mobile setup
		document.ontouchmove = function (event) {
			event.preventDefault();
		}
	</script>

</body>

</html>