<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
	<title>Edge Detection - Finding Edges</title>
	
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">
	<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
	<link rel="stylesheet" href="/styles.css">
	<link rel="stylesheet" href="../css/style.css">
	<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
	<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

	<script type="text/javascript" src="/main.js"></script>
</head>

<body class="flex-content-container">
	<div class="flex-content">

		<div class="col-sm-6 col-md-offset-3" id="content">

			<h1>Finding Edges</h1>
			<br>

			<p>
				We have defined edges as locations where drastic changes in intensity occur. To find these locations, we
				need some way of quantifying how much the intensity changes as we move across the pixels in our image.
				To illustrate this problem, let us re-imagine our pixel array as a 3D topological map, correlating the
				intensity of each pixel with height on the map.
			</p>

			<br>
			<div id="topology-root"></div>
			<br>

			<p>
				Picking an arbitrary point on this map, we want to figure out the change in elevation around that point.
				Knowing the pointâ€™s height alone is relatively unhelpful since, although it may tell us how high up it
				is, we get no information about the changes around it. What if, in addition, we also considered the
				height of land a small distance away from our chosen point? Ah-hah! Now by comparing these nearby
				heights, we can get some idea of the local elevation changes around the point!
			</p>

			<br>
			<img src="../images/elevation.png" alt="Elevation comparison example" class="center display-image">
			<br><br>

			<p>
				This is the driving principle behind a well-known edge detector called the <strong>Sobel
					operator</strong>. The operator works by dragging two <strong>kernels</strong> or
				<strong>filters</strong> called Sobel X and Sobel Y across an image to calculate horizontal and vertical
				intensity changes respectively. For each target pixel in the image, the kernel covers and performs an
				operation on a neighborhood of surrounding pixels. We compare the intensity of these neighboring pixels
				with each other and use them to compute the change of intensity at the target pixel. To demonstrate
				this, below is an interactive example using the Sobel X filter. Brighter areas in the result are
				indicative of large positive horizontal changes while darker areas are indicative of large negative
				horizontal changes. Use your mouse to drag the filter around and see how different areas reflect
				different intensity changes.
			</p>

			<br>
			<div id="convolution-root"></div>
			<br>

			<p>
				Numerically, these filters are actually grids of values that are matched up to each neighborhood of
				pixels and used in a weighted sum to calculate the change at each target pixel. In general, this concept
				of operating on a grid of values by dragging a smaller grid of values across it is a powerful
				mathematical idea that goes beyond edge detection known as <strong>convolution</strong>.
			</p>

			<br>
			<img src="../images/filters.png" alt="Sobel X and Y filters" class="center display-image">
			<br><br>

			<p>
				The end result of applying both the Sobel X and Sobel Y filters to our image is two grids containing
				values that represent horizontal and vertical changes respectively. These values can also be thought of
				as the X and Y components for a grid of 2D arrows or vectors. The vectors gotten using the Sobel
				operator are known as <strong>gradients</strong>. For a given pixel, the magnitude of the gradient tells
				us how much intensity change occurs at the pixel and the angle tells us the direction of the greatest
				change from the pixel.
			</p>

			<p>
				Below is a demonstration that calculates image gradients. Draw edges or select one of the preset images
				and observe how the direction and magnitude of the gradient vectors change in response. The magnitude of
				the vectors is indicated by color with blue being small and red being large.
			</p>

			<br>
			<div id="gradient-root"></div>
			<br>

			<p>
				Displaying the gradient magnitudes, we can see edges begin to manifest as pixels where the change in
				intensity is strong are lit up.
			</p>

			<p>
				We have reasoned out a way to evaluate intensity change for a given pixel by observing its neighbors. We
				have also introduced the Sobel operator which uses this reasoning to find the horizontal and vertical
				intensity change at every pixel. This allows us to build gradient vectors, giving us information about
				the amount and direction of intensity change at every pixel. In the next section, we will build upon our
				working edge detection algorithm to improve its performance.
			</p>

			<br>
			<div id="pipeline-grad-root"></div>
			<br>

			<div class="row">
				<div class="col-sm-6 text-left">
					<a href="../1-Introduction/"><i class="fas fa-arrow-left"></i> Prev</a>
				</div>
				<div class="col-sm-6 text-right">
					<a href="../3-Robust-Edge-Detection/">Next <i class="fas fa-arrow-right"></i></a>
				</div>
			</div>
			<br>
		</div>
	</div>


	<!-- Replace with third party -->
	<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
	<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/106/three.js"></script>
	<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script src="/third-party/OrbitControls.js"></script>
	<script src="/third-party/vis.min.js"></script>

	<script type="text/javascript" src="../js/setup.js"></script>
	<script type="text/javascript" src="../js/util.js"></script>
	<script type="text/javascript" src="../js/ui.js"></script>
	<script type="text/javascript" src="../js/imageProcessing.js"></script>

	<script type="text/javascript" src="./js/demoConvolution.js"></script>
	<script type="text/javascript" src="./js/demoGradient.js"></script>
	<script type="text/javascript" src="./js/demoTopology.js"></script>

	<script type="text/javascript">
		// mobile setup
		document.ontouchmove = function (event) {
			event.preventDefault();
		}
	</script>

</body>

</html>